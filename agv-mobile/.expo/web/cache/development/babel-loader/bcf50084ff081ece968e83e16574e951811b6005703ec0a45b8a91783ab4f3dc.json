{"ast":null,"code":"import { UnavailabilityError } from 'expo-modules-core';\nimport { PermissionStatus } from './Camera.types';\nimport { canGetUserMedia, isBackCameraAvailableAsync, isFrontCameraAvailableAsync } from './web/WebUserMediaManager';\nfunction getUserMedia(constraints) {\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    return navigator.mediaDevices.getUserMedia(constraints);\n  }\n  const getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || function () {\n    const error = new Error('Permission unimplemented');\n    error.code = 0;\n    error.name = 'NotAllowedError';\n    throw error;\n  };\n  return new Promise((resolve, reject) => {\n    getUserMedia.call(navigator, constraints, resolve, reject);\n  });\n}\nfunction handleGetUserMediaError({\n  message\n}) {\n  if (message === 'Permission dismissed') {\n    return {\n      status: PermissionStatus.UNDETERMINED,\n      expires: 'never',\n      canAskAgain: true,\n      granted: false\n    };\n  } else {\n    return {\n      status: PermissionStatus.DENIED,\n      expires: 'never',\n      canAskAgain: true,\n      granted: false\n    };\n  }\n}\nasync function handleRequestPermissionsAsync() {\n  try {\n    const streams = await getUserMedia({\n      video: true\n    });\n    streams.getTracks().forEach(track => {\n      track.stop();\n      streams.removeTrack(track);\n    });\n    return {\n      status: PermissionStatus.GRANTED,\n      expires: 'never',\n      canAskAgain: true,\n      granted: true\n    };\n  } catch (error) {\n    return handleGetUserMediaError(error.message);\n  }\n}\nasync function handlePermissionsQueryAsync(query) {\n  if (!navigator?.permissions?.query) {\n    throw new UnavailabilityError('expo-camera', 'navigator.permissions API is not available');\n  }\n  try {\n    const {\n      state\n    } = await navigator.permissions.query({\n      name: query\n    });\n    switch (state) {\n      case 'prompt':\n        return {\n          status: PermissionStatus.UNDETERMINED,\n          expires: 'never',\n          canAskAgain: true,\n          granted: false\n        };\n      case 'granted':\n        return {\n          status: PermissionStatus.GRANTED,\n          expires: 'never',\n          canAskAgain: true,\n          granted: true\n        };\n      case 'denied':\n        return {\n          status: PermissionStatus.DENIED,\n          expires: 'never',\n          canAskAgain: true,\n          granted: false\n        };\n    }\n  } catch (e) {\n    if (e instanceof TypeError) {\n      return {\n        status: PermissionStatus.UNDETERMINED,\n        expires: 'never',\n        canAskAgain: true,\n        granted: false\n      };\n    }\n    throw e;\n  }\n}\nexport default {\n  get Type() {\n    return {\n      back: 'back',\n      front: 'front'\n    };\n  },\n  get FlashMode() {\n    return {\n      on: 'on',\n      off: 'off',\n      auto: 'auto',\n      torch: 'torch'\n    };\n  },\n  get AutoFocus() {\n    return {\n      on: 'on',\n      off: 'off',\n      auto: 'auto',\n      singleShot: 'singleShot'\n    };\n  },\n  get WhiteBalance() {\n    return {\n      auto: 'auto',\n      continuous: 'continuous',\n      manual: 'manual'\n    };\n  },\n  get VideoQuality() {\n    return {};\n  },\n  get VideoStabilization() {\n    return {};\n  },\n  async isAvailableAsync() {\n    return canGetUserMedia();\n  },\n  async takePicture(options, camera) {\n    return await camera.takePicture(options);\n  },\n  async pausePreview(camera) {\n    await camera.pausePreview();\n  },\n  async resumePreview(camera) {\n    return await camera.resumePreview();\n  },\n  async getAvailableCameraTypesAsync() {\n    if (!canGetUserMedia() || !navigator.mediaDevices.enumerateDevices) return [];\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const types = await Promise.all([(await isFrontCameraAvailableAsync(devices)) && 'front', (await isBackCameraAvailableAsync()) && 'back']);\n    return types.filter(Boolean);\n  },\n  async getAvailablePictureSizes(ratio, camera) {\n    return await camera.getAvailablePictureSizes(ratio);\n  },\n  async getPermissionsAsync() {\n    return handlePermissionsQueryAsync('camera');\n  },\n  async requestPermissionsAsync() {\n    return handleRequestPermissionsAsync();\n  },\n  async getCameraPermissionsAsync() {\n    return handlePermissionsQueryAsync('camera');\n  },\n  async requestCameraPermissionsAsync() {\n    return handleRequestPermissionsAsync();\n  },\n  async getMicrophonePermissionsAsync() {\n    return handlePermissionsQueryAsync('microphone');\n  },\n  async requestMicrophonePermissionsAsync() {\n    try {\n      await getUserMedia({\n        audio: true\n      });\n      return {\n        status: PermissionStatus.GRANTED,\n        expires: 'never',\n        canAskAgain: true,\n        granted: true\n      };\n    } catch (error) {\n      return handleGetUserMediaError(error.message);\n    }\n  }\n};","map":{"version":3,"names":["UnavailabilityError","PermissionStatus","canGetUserMedia","isBackCameraAvailableAsync","isFrontCameraAvailableAsync","getUserMedia","constraints","navigator","mediaDevices","webkitGetUserMedia","mozGetUserMedia","error","Error","code","name","Promise","resolve","reject","call","handleGetUserMediaError","message","status","UNDETERMINED","expires","canAskAgain","granted","DENIED","handleRequestPermissionsAsync","streams","video","getTracks","forEach","track","stop","removeTrack","GRANTED","handlePermissionsQueryAsync","query","permissions","state","e","TypeError","Type","back","front","FlashMode","on","off","auto","torch","AutoFocus","singleShot","WhiteBalance","continuous","manual","VideoQuality","VideoStabilization","isAvailableAsync","takePicture","options","camera","pausePreview","resumePreview","getAvailableCameraTypesAsync","enumerateDevices","devices","types","all","filter","Boolean","getAvailablePictureSizes","ratio","getPermissionsAsync","requestPermissionsAsync","getCameraPermissionsAsync","requestCameraPermissionsAsync","getMicrophonePermissionsAsync","requestMicrophonePermissionsAsync","audio"],"sources":["C:\\Users\\VCP2909\\Desktop\\AGV\\AGV-MAC2\\agv-mobile\\node_modules\\expo-camera\\src\\ExpoCameraManager.web.ts"],"sourcesContent":["import { UnavailabilityError } from 'expo-modules-core';\n\nimport {\n  CameraCapturedPicture,\n  CameraPictureOptions,\n  PermissionResponse,\n  PermissionStatus,\n} from './Camera.types';\nimport { ExponentCameraRef } from './ExpoCamera.web';\nimport {\n  canGetUserMedia,\n  isBackCameraAvailableAsync,\n  isFrontCameraAvailableAsync,\n} from './web/WebUserMediaManager';\n\nfunction getUserMedia(constraints: MediaStreamConstraints): Promise<MediaStream> {\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    return navigator.mediaDevices.getUserMedia(constraints);\n  }\n\n  // Some browsers partially implement mediaDevices. We can't just assign an object\n  // with getUserMedia as it would overwrite existing properties.\n  // Here, we will just add the getUserMedia property if it's missing.\n\n  // First get ahold of the legacy getUserMedia, if present\n  const getUserMedia =\n    // TODO: this method is deprecated, migrate to https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia\n    navigator.getUserMedia ||\n    navigator.webkitGetUserMedia ||\n    navigator.mozGetUserMedia ||\n    function () {\n      const error: any = new Error('Permission unimplemented');\n      error.code = 0;\n      error.name = 'NotAllowedError';\n      throw error;\n    };\n  return new Promise((resolve, reject) => {\n    // TODO(@kitten): The types indicates that this is incorrect.\n    // Please check whether this is correct!\n    // @ts-expect-error: The `successCallback` doesn't match a `resolve` function\n    getUserMedia.call(navigator, constraints, resolve, reject);\n  });\n}\n\nfunction handleGetUserMediaError({ message }: { message: string }): PermissionResponse {\n  // name: NotAllowedError\n  // code: 0\n  if (message === 'Permission dismissed') {\n    return {\n      status: PermissionStatus.UNDETERMINED,\n      expires: 'never',\n      canAskAgain: true,\n      granted: false,\n    };\n  } else {\n    // TODO: Bacon: [OSX] The system could deny access to chrome.\n    // TODO: Bacon: add: { status: 'unimplemented' }\n    return {\n      status: PermissionStatus.DENIED,\n      expires: 'never',\n      canAskAgain: true,\n      granted: false,\n    };\n  }\n}\n\nasync function handleRequestPermissionsAsync(): Promise<PermissionResponse> {\n  try {\n    const streams = await getUserMedia({\n      video: true,\n    });\n    // We need to close the media stream returned by getUserMedia\n    // to avoid using the camera since we won't use these streams now\n    // https://developer.mozilla.org/fr/docs/Web/API/MediaDevices/getUserMedia\n    streams.getTracks().forEach((track) => {\n      track.stop();\n      streams.removeTrack(track);\n    });\n    return {\n      status: PermissionStatus.GRANTED,\n      expires: 'never',\n      canAskAgain: true,\n      granted: true,\n    };\n  } catch (error: any) {\n    return handleGetUserMediaError(error.message);\n  }\n}\n\nasync function handlePermissionsQueryAsync(\n  query: 'camera' | 'microphone'\n): Promise<PermissionResponse> {\n  if (!navigator?.permissions?.query) {\n    throw new UnavailabilityError('expo-camera', 'navigator.permissions API is not available');\n  }\n\n  try {\n    const { state } = await navigator.permissions.query({ name: query });\n    switch (state) {\n      case 'prompt':\n        return {\n          status: PermissionStatus.UNDETERMINED,\n          expires: 'never',\n          canAskAgain: true,\n          granted: false,\n        };\n      case 'granted':\n        return {\n          status: PermissionStatus.GRANTED,\n          expires: 'never',\n          canAskAgain: true,\n          granted: true,\n        };\n      case 'denied':\n        return {\n          status: PermissionStatus.DENIED,\n          expires: 'never',\n          canAskAgain: true,\n          granted: false,\n        };\n    }\n  } catch (e) {\n    // Firefox doesn't support querying for the camera permission, so return undetermined status\n    if (e instanceof TypeError) {\n      return {\n        status: PermissionStatus.UNDETERMINED,\n        expires: 'never',\n        canAskAgain: true,\n        granted: false,\n      };\n    }\n    throw e;\n  }\n}\n\nexport default {\n  get Type() {\n    return {\n      back: 'back',\n      front: 'front',\n    };\n  },\n  get FlashMode() {\n    return {\n      on: 'on',\n      off: 'off',\n      auto: 'auto',\n      torch: 'torch',\n    };\n  },\n  get AutoFocus() {\n    return {\n      on: 'on',\n      off: 'off',\n      auto: 'auto',\n      singleShot: 'singleShot',\n    };\n  },\n  get WhiteBalance() {\n    return {\n      auto: 'auto',\n      continuous: 'continuous',\n      manual: 'manual',\n    };\n  },\n  get VideoQuality() {\n    return {};\n  },\n  get VideoStabilization() {\n    return {};\n  },\n  async isAvailableAsync(): Promise<boolean> {\n    return canGetUserMedia();\n  },\n  async takePicture(\n    options: CameraPictureOptions,\n    camera: ExponentCameraRef\n  ): Promise<CameraCapturedPicture> {\n    return await camera.takePicture(options);\n  },\n  async pausePreview(camera: ExponentCameraRef): Promise<void> {\n    await camera.pausePreview();\n  },\n  async resumePreview(camera: ExponentCameraRef): Promise<void> {\n    return await camera.resumePreview();\n  },\n  async getAvailableCameraTypesAsync(): Promise<string[]> {\n    if (!canGetUserMedia() || !navigator.mediaDevices.enumerateDevices) return [];\n\n    const devices = await navigator.mediaDevices.enumerateDevices();\n\n    const types: (string | null)[] = await Promise.all([\n      (await isFrontCameraAvailableAsync(devices)) && 'front',\n      (await isBackCameraAvailableAsync()) && 'back',\n    ]);\n\n    return types.filter(Boolean) as string[];\n  },\n  async getAvailablePictureSizes(ratio: string, camera: ExponentCameraRef): Promise<string[]> {\n    return await camera.getAvailablePictureSizes(ratio);\n  },\n  /*\n  async record(\n    options?: CameraRecordingOptions,\n    camera: ExponentCameraRef\n  ): Promise<{ uri: string }> {\n    // TODO: Support on web\n  },\n  async stopRecording(camera: ExponentCameraRef): Promise<void> {\n    // TODO: Support on web\n  }, */\n  async getPermissionsAsync(): Promise<PermissionResponse> {\n    return handlePermissionsQueryAsync('camera');\n  },\n  async requestPermissionsAsync(): Promise<PermissionResponse> {\n    return handleRequestPermissionsAsync();\n  },\n  async getCameraPermissionsAsync(): Promise<PermissionResponse> {\n    return handlePermissionsQueryAsync('camera');\n  },\n  async requestCameraPermissionsAsync(): Promise<PermissionResponse> {\n    return handleRequestPermissionsAsync();\n  },\n  async getMicrophonePermissionsAsync(): Promise<PermissionResponse> {\n    return handlePermissionsQueryAsync('microphone');\n  },\n  async requestMicrophonePermissionsAsync(): Promise<PermissionResponse> {\n    try {\n      await getUserMedia({\n        audio: true,\n      });\n      return {\n        status: PermissionStatus.GRANTED,\n        expires: 'never',\n        canAskAgain: true,\n        granted: true,\n      };\n    } catch (error: any) {\n      return handleGetUserMediaError(error.message);\n    }\n  },\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}