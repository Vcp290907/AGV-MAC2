{"ast":null,"code":"import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/objectWithoutPropertiesLoose\";\nconst _excluded = [\"facing\", \"poster\", \"ref\"];\nvar _jsxFileName = \"C:\\\\Users\\\\VCP2909\\\\Desktop\\\\AGV\\\\AGV-MAC2\\\\agv-mobile\\\\node_modules\\\\expo-camera\\\\build\\\\ExpoCamera.web.js\";\nimport { CodedError } from 'expo-modules-core';\nimport { useRef, useMemo, useImperativeHandle } from 'react';\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport View from \"react-native-web/dist/exports/View\";\nimport createElement from 'react-native-web/dist/exports/createElement';\nimport CameraManager from './ExpoCameraManager.web';\nimport { capture } from './web/WebCameraUtils';\nimport { PictureSizes } from './web/WebConstants';\nimport { useWebCameraStream } from './web/useWebCameraStream';\nimport { useWebQRScanner } from './web/useWebQRScanner';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ExponentCamera = _ref => {\n  let {\n      facing,\n      poster,\n      ref\n    } = _ref,\n    props = _objectWithoutPropertiesLoose(_ref, _excluded);\n  const video = useRef(null);\n  const native = useWebCameraStream(video, facing, props, {\n    onCameraReady() {\n      if (props.onCameraReady) {\n        props.onCameraReady();\n      }\n    },\n    onMountError: props.onMountError\n  });\n  const isQRScannerEnabled = useMemo(() => {\n    return Boolean(props.barcodeScannerSettings?.barcodeTypes?.includes('qr') && !!props.onBarcodeScanned);\n  }, [props.barcodeScannerSettings?.barcodeTypes, props.onBarcodeScanned]);\n  useWebQRScanner(video, {\n    interval: 300,\n    isEnabled: isQRScannerEnabled,\n    captureOptions: {\n      scale: 1,\n      isImageMirror: native.type === 'front'\n    },\n    onScanned(event) {\n      if (props.onBarcodeScanned) {\n        props.onBarcodeScanned(event);\n      }\n    }\n  });\n  useImperativeHandle(ref, () => ({\n    async getAvailablePictureSizes() {\n      return PictureSizes;\n    },\n    async takePicture(options) {\n      if (!video.current || video.current?.readyState !== video.current?.HAVE_ENOUGH_DATA) {\n        throw new CodedError('ERR_CAMERA_NOT_READY', 'HTMLVideoElement does not have enough camera data to construct an image yet.');\n      }\n      const settings = native.mediaTrackSettings;\n      if (!settings) {\n        throw new CodedError('ERR_CAMERA_NOT_READY', 'MediaStream is not ready yet.');\n      }\n      return capture(video.current, settings, Object.assign({}, options, {\n        onPictureSaved(picture) {\n          if (options.onPictureSaved) {\n            options.onPictureSaved(picture);\n          }\n          if (props.onPictureSaved) {\n            props.onPictureSaved({\n              nativeEvent: {\n                data: picture,\n                id: -1\n              }\n            });\n          }\n        }\n      }));\n    },\n    async resumePreview() {\n      if (video.current) {\n        video.current.play();\n      }\n    },\n    async pausePreview() {\n      if (video.current) {\n        video.current.pause();\n      }\n    },\n    async stopRecording() {\n      console.warn('stopRecording is not supported on web.');\n    },\n    async record() {\n      console.warn('record is not supported on web.');\n      return {\n        uri: ''\n      };\n    },\n    async toggleRecording() {\n      console.warn('toggleRecording is not supported on web.');\n    },\n    async launchModernScanner() {\n      console.warn('launchModernScanner is not supported on web.');\n    },\n    async getAvailableLenses() {\n      console.warn('getAvailableLenses is not supported on web.');\n      return [];\n    }\n  }), [native.mediaTrackSettings, props.onPictureSaved]);\n  const isMuted = true;\n  const style = useMemo(() => {\n    const isFrontFacingCamera = native.type === CameraManager.Type.front;\n    return [StyleSheet.absoluteFill, styles.video, {\n      pointerEvents: props.pointerEvents,\n      transform: isFrontFacingCamera ? [{\n        scaleX: -1\n      }] : undefined\n    }];\n  }, [props.pointerEvents, native.type]);\n  return _jsxDEV(View, {\n    style: [styles.videoWrapper, props.style],\n    children: [_jsxDEV(Video, {\n      autoPlay: true,\n      playsInline: true,\n      muted: isMuted,\n      poster: poster,\n      ref: video,\n      style: style\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 102,\n      columnNumber: 7\n    }, this), props.children]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 101,\n    columnNumber: 13\n  }, this);\n};\nexport default ExponentCamera;\nconst Video = props => createElement('video', Object.assign({}, props));\nconst styles = StyleSheet.create({\n  videoWrapper: {\n    flex: 1,\n    alignItems: 'stretch',\n    pointerEvents: 'box-none'\n  },\n  video: {\n    width: '100%',\n    height: '100%',\n    objectFit: 'cover'\n  }\n});","map":{"version":3,"names":["CodedError","useRef","useMemo","useImperativeHandle","StyleSheet","View","createElement","CameraManager","capture","PictureSizes","useWebCameraStream","useWebQRScanner","jsxDEV","_jsxDEV","ExponentCamera","_ref","facing","poster","ref","props","_objectWithoutPropertiesLoose","_excluded","video","native","onCameraReady","onMountError","isQRScannerEnabled","Boolean","barcodeScannerSettings","barcodeTypes","includes","onBarcodeScanned","interval","isEnabled","captureOptions","scale","isImageMirror","type","onScanned","event","getAvailablePictureSizes","takePicture","options","current","readyState","HAVE_ENOUGH_DATA","settings","mediaTrackSettings","Object","assign","onPictureSaved","picture","nativeEvent","data","id","resumePreview","play","pausePreview","pause","stopRecording","console","warn","record","uri","toggleRecording","launchModernScanner","getAvailableLenses","isMuted","style","isFrontFacingCamera","Type","front","absoluteFill","styles","pointerEvents","transform","scaleX","undefined","videoWrapper","children","Video","autoPlay","playsInline","muted","fileName","_jsxFileName","lineNumber","columnNumber","create","flex","alignItems","width","height","objectFit"],"sources":["C:\\Users\\VCP2909\\Desktop\\AGV\\AGV-MAC2\\agv-mobile\\node_modules\\expo-camera\\src\\ExpoCamera.web.tsx"],"sourcesContent":["import { CodedError } from 'expo-modules-core';\nimport {\n  type PropsWithChildren,\n  useRef,\n  useMemo,\n  useImperativeHandle,\n  type ComponentProps,\n  type Ref,\n} from 'react';\nimport { StyleProp, StyleSheet, View, ViewStyle } from 'react-native';\nimport createElement from 'react-native-web/dist/exports/createElement';\n\nimport {\n  CameraNativeProps,\n  CameraCapturedPicture,\n  CameraPictureOptions,\n  CameraType,\n} from './Camera.types';\nimport CameraManager from './ExpoCameraManager.web';\nimport { capture } from './web/WebCameraUtils';\nimport { PictureSizes } from './web/WebConstants';\nimport { useWebCameraStream } from './web/useWebCameraStream';\nimport { useWebQRScanner } from './web/useWebQRScanner';\n\nexport interface ExponentCameraRef {\n  getAvailablePictureSizes: (ratio: string) => Promise<string[]>;\n  takePicture: (options: CameraPictureOptions) => Promise<CameraCapturedPicture>;\n  resumePreview: () => Promise<void>;\n  pausePreview: () => Promise<void>;\n}\n\nconst ExponentCamera = ({\n  facing,\n  poster,\n  ref,\n  ...props\n}: PropsWithChildren<CameraNativeProps>) => {\n  const video = useRef<HTMLVideoElement | null>(null);\n\n  const native = useWebCameraStream(video, facing as CameraType, props, {\n    onCameraReady() {\n      if (props.onCameraReady) {\n        props.onCameraReady();\n      }\n    },\n    onMountError: props.onMountError,\n  });\n\n  const isQRScannerEnabled = useMemo<boolean>(() => {\n    return Boolean(\n      props.barcodeScannerSettings?.barcodeTypes?.includes('qr') && !!props.onBarcodeScanned\n    );\n  }, [props.barcodeScannerSettings?.barcodeTypes, props.onBarcodeScanned]);\n\n  useWebQRScanner(video, {\n    interval: 300,\n    isEnabled: isQRScannerEnabled,\n    captureOptions: { scale: 1, isImageMirror: native.type === 'front' },\n    onScanned(event) {\n      if (props.onBarcodeScanned) {\n        props.onBarcodeScanned(event);\n      }\n    },\n  });\n\n  useImperativeHandle(\n    ref,\n    () => ({\n      async getAvailablePictureSizes(): Promise<string[]> {\n        return PictureSizes;\n      },\n      async takePicture(options: CameraPictureOptions): Promise<CameraCapturedPicture> {\n        if (!video.current || video.current?.readyState !== video.current?.HAVE_ENOUGH_DATA) {\n          throw new CodedError(\n            'ERR_CAMERA_NOT_READY',\n            'HTMLVideoElement does not have enough camera data to construct an image yet.'\n          );\n        }\n        const settings = native.mediaTrackSettings;\n        if (!settings) {\n          throw new CodedError('ERR_CAMERA_NOT_READY', 'MediaStream is not ready yet.');\n        }\n\n        return capture(video.current, settings, {\n          ...options,\n          // This will always be defined, the option gets added to a queue in the upper-level. We should replace the original so it isn't called twice.\n          onPictureSaved(picture) {\n            if (options.onPictureSaved) {\n              options.onPictureSaved(picture);\n            }\n            if (props.onPictureSaved) {\n              props.onPictureSaved({ nativeEvent: { data: picture, id: -1 } });\n            }\n          },\n        });\n      },\n      async resumePreview(): Promise<void> {\n        if (video.current) {\n          video.current.play();\n        }\n      },\n      async pausePreview(): Promise<void> {\n        if (video.current) {\n          video.current.pause();\n        }\n      },\n      async stopRecording(): Promise<void> {\n        console.warn('stopRecording is not supported on web.');\n      },\n      async record(): Promise<{ uri: string }> {\n        console.warn('record is not supported on web.');\n        return { uri: '' };\n      },\n      async toggleRecording() {\n        console.warn('toggleRecording is not supported on web.');\n      },\n      async launchModernScanner() {\n        console.warn('launchModernScanner is not supported on web.');\n      },\n      async getAvailableLenses() {\n        console.warn('getAvailableLenses is not supported on web.');\n        return [];\n      },\n    }),\n    [native.mediaTrackSettings, props.onPictureSaved]\n  );\n\n  // TODO(Bacon): Create a universal prop, on native the microphone is only used when recording videos.\n  // Because we don't support recording video in the browser we don't need the user to give microphone permissions.\n  const isMuted = true;\n\n  const style = useMemo<StyleProp<ViewStyle>>(() => {\n    const isFrontFacingCamera = native.type === CameraManager.Type.front;\n    return [\n      StyleSheet.absoluteFill,\n      styles.video,\n      {\n        pointerEvents: props.pointerEvents,\n        // Flip the camera\n        transform: isFrontFacingCamera ? [{ scaleX: -1 }] : undefined,\n      },\n    ];\n  }, [props.pointerEvents, native.type]);\n\n  return (\n    <View style={[styles.videoWrapper, props.style]}>\n      <Video autoPlay playsInline muted={isMuted} poster={poster} ref={video} style={style} />\n      {props.children}\n    </View>\n  );\n};\n\nexport default ExponentCamera;\n\nconst Video = (\n  props: ComponentProps<typeof View> & {\n    autoPlay?: boolean;\n    playsInline?: boolean;\n    muted?: boolean;\n    poster?: string;\n    ref: Ref<HTMLVideoElement>;\n  }\n) => createElement('video', { ...props });\n\nconst styles = StyleSheet.create({\n  videoWrapper: {\n    flex: 1,\n    alignItems: 'stretch',\n    pointerEvents: 'box-none',\n  },\n  video: {\n    width: '100%',\n    height: '100%',\n    objectFit: 'cover',\n  },\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}