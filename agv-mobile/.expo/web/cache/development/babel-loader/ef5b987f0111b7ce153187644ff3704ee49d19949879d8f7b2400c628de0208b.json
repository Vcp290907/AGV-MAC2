{"ast":null,"code":"import { Platform } from 'expo-modules-core';\nexport const userMediaRequested = false;\nexport const mountedInstances = [];\nasync function requestLegacyUserMediaAsync(props) {\n  const optionalSource = id => ({\n    optional: [{\n      sourceId: id\n    }]\n  });\n  const constraintToSourceId = constraint => {\n    const {\n      deviceId\n    } = constraint;\n    if (typeof deviceId === 'string') {\n      return deviceId;\n    }\n    if (Array.isArray(deviceId)) {\n      return deviceId[0] ?? null;\n    } else if (typeof deviceId === 'object' && deviceId.ideal) {\n      return deviceId.ideal;\n    }\n    return null;\n  };\n  const sources = await new Promise(resolve => MediaStreamTrack.getSources(sources => resolve(sources)));\n  let audioSource = null;\n  let videoSource = null;\n  sources.forEach(source => {\n    if (source.kind === 'audio') {\n      audioSource = source.id;\n    } else if (source.kind === 'video') {\n      videoSource = source.id;\n    }\n  });\n  const audioSourceId = constraintToSourceId(props.audioConstraints);\n  if (audioSourceId) {\n    audioSource = audioSourceId;\n  }\n  const videoSourceId = constraintToSourceId(props.videoConstraints);\n  if (videoSourceId) {\n    videoSource = videoSourceId;\n  }\n  return [optionalSource(audioSource), optionalSource(videoSource)];\n}\nasync function sourceSelectedAsync(isMuted, audioConstraints, videoConstraints) {\n  const constraints = {\n    video: typeof videoConstraints !== 'undefined' ? videoConstraints : true\n  };\n  if (!isMuted) {\n    constraints.audio = typeof audioConstraints !== 'undefined' ? audioConstraints : true;\n  }\n  return await getAnyUserMediaAsync(constraints);\n}\nexport async function requestUserMediaAsync(props, isMuted = true) {\n  if (canGetUserMedia()) {\n    return await sourceSelectedAsync(isMuted, props.audio, props.video);\n  }\n  const [audio, video] = await requestLegacyUserMediaAsync(props);\n  return await sourceSelectedAsync(isMuted, audio, video);\n}\nexport async function getAnyUserMediaAsync(constraints, ignoreConstraints = false) {\n  try {\n    return await getUserMediaAsync(Object.assign({}, constraints, {\n      video: ignoreConstraints || constraints.video\n    }));\n  } catch (error) {\n    if (!ignoreConstraints && typeof error === 'object' && error?.name === 'ConstraintNotSatisfiedError') {\n      return await getAnyUserMediaAsync(constraints, true);\n    }\n    throw error;\n  }\n}\nexport async function getUserMediaAsync(constraints) {\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    return navigator.mediaDevices.getUserMedia(constraints);\n  }\n  const _getUserMedia = navigator['mozGetUserMedia'] || navigator['webkitGetUserMedia'] || navigator['msGetUserMedia'];\n  return new Promise((resolve, reject) => _getUserMedia.call(navigator, constraints, resolve, reject));\n}\nexport function canGetUserMedia() {\n  return (Platform.isDOMAvailable && !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia || navigator['mozGetUserMedia'] || navigator['webkitGetUserMedia'] || navigator['msGetUserMedia'])\n  );\n}\nexport async function isFrontCameraAvailableAsync(devices) {\n  return await supportsCameraType(['front', 'user', 'facetime'], 'user', devices);\n}\nexport async function isBackCameraAvailableAsync(devices) {\n  return await supportsCameraType(['back', 'rear'], 'environment', devices);\n}\nasync function supportsCameraType(labels, type, devices) {\n  if (!devices) {\n    if (!navigator.mediaDevices.enumerateDevices) {\n      return null;\n    }\n    devices = await navigator.mediaDevices.enumerateDevices();\n  }\n  const cameras = devices.filter(t => t.kind === 'videoinput');\n  const [hasCamera] = cameras.filter(camera => labels.some(label => camera.label.toLowerCase().includes(label)));\n  const [isCapable] = cameras.filter(camera => {\n    if (!('getCapabilities' in camera)) {\n      return null;\n    }\n    const capabilities = camera.getCapabilities();\n    if (!capabilities.facingMode) {\n      return null;\n    }\n    return capabilities.facingMode.find(_ => type);\n  });\n  return isCapable?.deviceId || hasCamera?.deviceId || null;\n}","map":{"version":3,"names":["Platform","userMediaRequested","mountedInstances","requestLegacyUserMediaAsync","props","optionalSource","id","optional","sourceId","constraintToSourceId","constraint","deviceId","Array","isArray","ideal","sources","Promise","resolve","MediaStreamTrack","getSources","audioSource","videoSource","forEach","source","kind","audioSourceId","audioConstraints","videoSourceId","videoConstraints","sourceSelectedAsync","isMuted","constraints","video","audio","getAnyUserMediaAsync","requestUserMediaAsync","canGetUserMedia","ignoreConstraints","getUserMediaAsync","Object","assign","error","name","navigator","mediaDevices","getUserMedia","_getUserMedia","reject","call","isDOMAvailable","isFrontCameraAvailableAsync","devices","supportsCameraType","isBackCameraAvailableAsync","labels","type","enumerateDevices","cameras","filter","t","hasCamera","camera","some","label","toLowerCase","includes","isCapable","capabilities","getCapabilities","facingMode","find","_"],"sources":["C:\\Users\\VCP2909\\Desktop\\AGV\\AGV-MAC2\\agv-mobile\\node_modules\\expo-camera\\src\\web\\WebUserMediaManager.ts"],"sourcesContent":["/* eslint-env browser */\n/**\n * A web-only module for ponyfilling the UserMedia API.\n */\nimport { Platform } from 'expo-modules-core';\n\nexport const userMediaRequested: boolean = false;\n\nexport const mountedInstances: any[] = [];\n\nasync function requestLegacyUserMediaAsync(\n  // TODO(@kitten): Type this properly\n  props: { audioConstraints?: any; videoConstraints?: any }\n): Promise<any[]> {\n  // TODO(@kitten): This is never type checked against DOM types\n  const optionalSource = (id: string | string[] | null) => ({ optional: [{ sourceId: id }] });\n\n  const constraintToSourceId = (constraint: MediaTrackConstraintSet) => {\n    const { deviceId } = constraint;\n\n    if (typeof deviceId === 'string') {\n      return deviceId;\n    }\n\n    if (Array.isArray(deviceId)) {\n      return deviceId[0] ?? null;\n    } else if (typeof deviceId === 'object' && deviceId.ideal) {\n      return deviceId.ideal;\n    }\n\n    return null;\n  };\n\n  const sources: any[] = await new Promise((resolve) =>\n    // @ts-ignore: https://caniuse.com/#search=getSources Chrome for Android (78) & Samsung Internet (10.1) use this\n    MediaStreamTrack.getSources((sources) => resolve(sources))\n  );\n\n  let audioSource = null;\n  let videoSource = null;\n\n  sources.forEach((source) => {\n    if (source.kind === 'audio') {\n      audioSource = source.id;\n    } else if (source.kind === 'video') {\n      videoSource = source.id;\n    }\n  });\n\n  // NOTE(@kitten): This doesn't seem right. The types that should be used here don't contain `audioConstraints`\n  // If this is legacy, the type shouldn't have been dropped but marked as `@deprecated`. Alternatively, remove this code path\n  const audioSourceId = constraintToSourceId(props.audioConstraints);\n  if (audioSourceId) {\n    audioSource = audioSourceId;\n  }\n\n  // NOTE(@kitten): This doesn't seem right. The types that should be used here don't contain `videoConstraints`\n  // If this is legacy, the type shouldn't have been dropped but marked as `@deprecated`. Alternatively, remove this code path\n  const videoSourceId = constraintToSourceId(props.videoConstraints);\n  if (videoSourceId) {\n    videoSource = videoSourceId;\n  }\n\n  return [optionalSource(audioSource), optionalSource(videoSource)];\n}\n\nasync function sourceSelectedAsync(\n  isMuted: boolean,\n  audioConstraints?: MediaTrackConstraints | boolean,\n  videoConstraints?: MediaTrackConstraints | boolean\n): Promise<MediaStream> {\n  const constraints: MediaStreamConstraints = {\n    video: typeof videoConstraints !== 'undefined' ? videoConstraints : true,\n  };\n\n  if (!isMuted) {\n    constraints.audio = typeof audioConstraints !== 'undefined' ? audioConstraints : true;\n  }\n\n  return await getAnyUserMediaAsync(constraints);\n}\n\nexport async function requestUserMediaAsync(\n  // TODO(@kitten): Type this properly\n  props: { audio?: any; video?: any },\n  isMuted: boolean = true\n): Promise<MediaStream> {\n  if (canGetUserMedia()) {\n    return await sourceSelectedAsync(isMuted, props.audio, props.video);\n  }\n  // NOTE(@kitten): This doesn't seem right. The types that should be used here don't contain `videoConstraints`\n  // If this is legacy, the type shouldn't have been dropped but marked as `@deprecated`. Alternatively, remove this code path\n  const [audio, video] = await requestLegacyUserMediaAsync(props as any);\n  return await sourceSelectedAsync(isMuted, audio, video);\n}\n\nexport async function getAnyUserMediaAsync(\n  constraints: MediaStreamConstraints,\n  ignoreConstraints: boolean = false\n): Promise<MediaStream> {\n  try {\n    return await getUserMediaAsync({\n      ...constraints,\n      video: ignoreConstraints || constraints.video,\n    });\n  } catch (error: any) {\n    if (\n      !ignoreConstraints &&\n      typeof error === 'object' &&\n      error?.name === 'ConstraintNotSatisfiedError'\n    ) {\n      return await getAnyUserMediaAsync(constraints, true);\n    }\n    throw error;\n  }\n}\n\nexport async function getUserMediaAsync(constraints: MediaStreamConstraints): Promise<MediaStream> {\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    return navigator.mediaDevices.getUserMedia(constraints);\n  }\n\n  const _getUserMedia =\n    navigator['mozGetUserMedia'] ||\n    navigator['webkitGetUserMedia'] ||\n    // @ts-expect-error: TODO(@kitten): Remove / Drop IE support\n    navigator['msGetUserMedia'];\n  return new Promise((resolve, reject) =>\n    _getUserMedia.call(navigator, constraints, resolve, reject)\n  );\n}\n\nexport function canGetUserMedia(): boolean {\n  // TODO(@kitten): This is misaligned with the implementations in `expo-audio/src/AudioModule.web.ts` and `expo-av`\n  return (\n    // SSR\n    Platform.isDOMAvailable &&\n    // Has any form of media API\n    !!(\n      (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) ||\n      navigator['mozGetUserMedia'] ||\n      navigator['webkitGetUserMedia'] ||\n      // @ts-expect-error: TODO(@kitten): Remove / Drop IE support\n      navigator['msGetUserMedia']\n    )\n  );\n}\n\nexport async function isFrontCameraAvailableAsync(\n  devices?: MediaDeviceInfo[]\n): Promise<null | string> {\n  return await supportsCameraType(['front', 'user', 'facetime'], 'user', devices);\n}\n\nexport async function isBackCameraAvailableAsync(\n  devices?: MediaDeviceInfo[]\n): Promise<null | string> {\n  return await supportsCameraType(['back', 'rear'], 'environment', devices);\n}\n\nasync function supportsCameraType(\n  labels: string[],\n  type: string,\n  devices?: MediaDeviceInfo[]\n): Promise<null | string> {\n  if (!devices) {\n    if (!navigator.mediaDevices.enumerateDevices) {\n      return null;\n    }\n    devices = await navigator.mediaDevices.enumerateDevices();\n  }\n  const cameras = devices.filter((t) => t.kind === 'videoinput');\n  const [hasCamera] = cameras.filter((camera) =>\n    labels.some((label) => camera.label.toLowerCase().includes(label))\n  );\n  const [isCapable] = cameras.filter((camera) => {\n    if (!('getCapabilities' in camera)) {\n      return null;\n    }\n\n    const capabilities = (camera as any).getCapabilities();\n    if (!capabilities.facingMode) {\n      return null;\n    }\n\n    return capabilities.facingMode.find((_: string) => type);\n  });\n\n  return isCapable?.deviceId || hasCamera?.deviceId || null;\n}\n"],"mappings":"AAIA,SAASA,QAAQ,QAAQ,mBAAmB;AAE5C,OAAO,MAAMC,kBAAkB,GAAY,KAAK;AAEhD,OAAO,MAAMC,gBAAgB,GAAU,EAAE;AAEzC,eAAeC,2BAA2BA,CAExCC,KAAyD;EAGzD,MAAMC,cAAc,GAAIC,EAA4B,KAAM;IAAEC,QAAQ,EAAE,CAAC;MAAEC,QAAQ,EAAEF;IAAE,CAAE;EAAC,CAAE,CAAC;EAE3F,MAAMG,oBAAoB,GAAIC,UAAmC,IAAI;IACnE,MAAM;MAAEC;IAAQ,CAAE,GAAGD,UAAU;IAE/B,IAAI,OAAOC,QAAQ,KAAK,QAAQ,EAAE;MAChC,OAAOA,QAAQ;IACjB;IAEA,IAAIC,KAAK,CAACC,OAAO,CAACF,QAAQ,CAAC,EAAE;MAC3B,OAAOA,QAAQ,CAAC,CAAC,CAAC,IAAI,IAAI;IAC5B,CAAC,MAAM,IAAI,OAAOA,QAAQ,KAAK,QAAQ,IAAIA,QAAQ,CAACG,KAAK,EAAE;MACzD,OAAOH,QAAQ,CAACG,KAAK;IACvB;IAEA,OAAO,IAAI;EACb,CAAC;EAED,MAAMC,OAAO,GAAU,MAAM,IAAIC,OAAO,CAAEC,OAAO,IAE/CC,gBAAgB,CAACC,UAAU,CAAEJ,OAAO,IAAKE,OAAO,CAACF,OAAO,CAAC,CAAC,CAC3D;EAED,IAAIK,WAAW,GAAG,IAAI;EACtB,IAAIC,WAAW,GAAG,IAAI;EAEtBN,OAAO,CAACO,OAAO,CAAEC,MAAM,IAAI;IACzB,IAAIA,MAAM,CAACC,IAAI,KAAK,OAAO,EAAE;MAC3BJ,WAAW,GAAGG,MAAM,CAACjB,EAAE;IACzB,CAAC,MAAM,IAAIiB,MAAM,CAACC,IAAI,KAAK,OAAO,EAAE;MAClCH,WAAW,GAAGE,MAAM,CAACjB,EAAE;IACzB;EACF,CAAC,CAAC;EAIF,MAAMmB,aAAa,GAAGhB,oBAAoB,CAACL,KAAK,CAACsB,gBAAgB,CAAC;EAClE,IAAID,aAAa,EAAE;IACjBL,WAAW,GAAGK,aAAa;EAC7B;EAIA,MAAME,aAAa,GAAGlB,oBAAoB,CAACL,KAAK,CAACwB,gBAAgB,CAAC;EAClE,IAAID,aAAa,EAAE;IACjBN,WAAW,GAAGM,aAAa;EAC7B;EAEA,OAAO,CAACtB,cAAc,CAACe,WAAW,CAAC,EAAEf,cAAc,CAACgB,WAAW,CAAC,CAAC;AACnE;AAEA,eAAeQ,mBAAmBA,CAChCC,OAAgB,EAChBJ,gBAAkD,EAClDE,gBAAkD;EAElD,MAAMG,WAAW,GAA2B;IAC1CC,KAAK,EAAE,OAAOJ,gBAAgB,KAAK,WAAW,GAAGA,gBAAgB,GAAG;GACrE;EAED,IAAI,CAACE,OAAO,EAAE;IACZC,WAAW,CAACE,KAAK,GAAG,OAAOP,gBAAgB,KAAK,WAAW,GAAGA,gBAAgB,GAAG,IAAI;EACvF;EAEA,OAAO,MAAMQ,oBAAoB,CAACH,WAAW,CAAC;AAChD;AAEA,OAAO,eAAeI,qBAAqBA,CAEzC/B,KAAmC,EACnC0B,OAAA,GAAmB,IAAI;EAEvB,IAAIM,eAAe,EAAE,EAAE;IACrB,OAAO,MAAMP,mBAAmB,CAACC,OAAO,EAAE1B,KAAK,CAAC6B,KAAK,EAAE7B,KAAK,CAAC4B,KAAK,CAAC;EACrE;EAGA,MAAM,CAACC,KAAK,EAAED,KAAK,CAAC,GAAG,MAAM7B,2BAA2B,CAACC,KAAY,CAAC;EACtE,OAAO,MAAMyB,mBAAmB,CAACC,OAAO,EAAEG,KAAK,EAAED,KAAK,CAAC;AACzD;AAEA,OAAO,eAAeE,oBAAoBA,CACxCH,WAAmC,EACnCM,iBAAA,GAA6B,KAAK;EAElC,IAAI;IACF,OAAO,MAAMC,iBAAiB,CAAAC,MAAA,CAAAC,MAAA,KACzBT,WAAW;MACdC,KAAK,EAAEK,iBAAiB,IAAIN,WAAW,CAACC;IAAK,EAC9C,CAAC;EACJ,CAAC,CAAC,OAAOS,KAAU,EAAE;IACnB,IACE,CAACJ,iBAAiB,IAClB,OAAOI,KAAK,KAAK,QAAQ,IACzBA,KAAK,EAAEC,IAAI,KAAK,6BAA6B,EAC7C;MACA,OAAO,MAAMR,oBAAoB,CAACH,WAAW,EAAE,IAAI,CAAC;IACtD;IACA,MAAMU,KAAK;EACb;AACF;AAEA,OAAO,eAAeH,iBAAiBA,CAACP,WAAmC;EACzE,IAAIY,SAAS,CAACC,YAAY,IAAID,SAAS,CAACC,YAAY,CAACC,YAAY,EAAE;IACjE,OAAOF,SAAS,CAACC,YAAY,CAACC,YAAY,CAACd,WAAW,CAAC;EACzD;EAEA,MAAMe,aAAa,GACjBH,SAAS,CAAC,iBAAiB,CAAC,IAC5BA,SAAS,CAAC,oBAAoB,CAAC,IAE/BA,SAAS,CAAC,gBAAgB,CAAC;EAC7B,OAAO,IAAI3B,OAAO,CAAC,CAACC,OAAO,EAAE8B,MAAM,KACjCD,aAAa,CAACE,IAAI,CAACL,SAAS,EAAEZ,WAAW,EAAEd,OAAO,EAAE8B,MAAM,CAAC,CAC5D;AACH;AAEA,OAAM,SAAUX,eAAeA,CAAA;EAE7B,QAEEpC,QAAQ,CAACiD,cAAc,IAEvB,CAAC,EACEN,SAAS,CAACC,YAAY,IAAID,SAAS,CAACC,YAAY,CAACC,YAAY,IAC9DF,SAAS,CAAC,iBAAiB,CAAC,IAC5BA,SAAS,CAAC,oBAAoB,CAAC,IAE/BA,SAAS,CAAC,gBAAgB,CAAC;EAC5B;AAEL;AAEA,OAAO,eAAeO,2BAA2BA,CAC/CC,OAA2B;EAE3B,OAAO,MAAMC,kBAAkB,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,UAAU,CAAC,EAAE,MAAM,EAAED,OAAO,CAAC;AACjF;AAEA,OAAO,eAAeE,0BAA0BA,CAC9CF,OAA2B;EAE3B,OAAO,MAAMC,kBAAkB,CAAC,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,aAAa,EAAED,OAAO,CAAC;AAC3E;AAEA,eAAeC,kBAAkBA,CAC/BE,MAAgB,EAChBC,IAAY,EACZJ,OAA2B;EAE3B,IAAI,CAACA,OAAO,EAAE;IACZ,IAAI,CAACR,SAAS,CAACC,YAAY,CAACY,gBAAgB,EAAE;MAC5C,OAAO,IAAI;IACb;IACAL,OAAO,GAAG,MAAMR,SAAS,CAACC,YAAY,CAACY,gBAAgB,EAAE;EAC3D;EACA,MAAMC,OAAO,GAAGN,OAAO,CAACO,MAAM,CAAEC,CAAC,IAAKA,CAAC,CAACnC,IAAI,KAAK,YAAY,CAAC;EAC9D,MAAM,CAACoC,SAAS,CAAC,GAAGH,OAAO,CAACC,MAAM,CAAEG,MAAM,IACxCP,MAAM,CAACQ,IAAI,CAAEC,KAAK,IAAKF,MAAM,CAACE,KAAK,CAACC,WAAW,EAAE,CAACC,QAAQ,CAACF,KAAK,CAAC,CAAC,CACnE;EACD,MAAM,CAACG,SAAS,CAAC,GAAGT,OAAO,CAACC,MAAM,CAAEG,MAAM,IAAI;IAC5C,IAAI,EAAE,iBAAiB,IAAIA,MAAM,CAAC,EAAE;MAClC,OAAO,IAAI;IACb;IAEA,MAAMM,YAAY,GAAIN,MAAc,CAACO,eAAe,EAAE;IACtD,IAAI,CAACD,YAAY,CAACE,UAAU,EAAE;MAC5B,OAAO,IAAI;IACb;IAEA,OAAOF,YAAY,CAACE,UAAU,CAACC,IAAI,CAAEC,CAAS,IAAKhB,IAAI,CAAC;EAC1D,CAAC,CAAC;EAEF,OAAOW,SAAS,EAAEvD,QAAQ,IAAIiD,SAAS,EAAEjD,QAAQ,IAAI,IAAI;AAC3D","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}