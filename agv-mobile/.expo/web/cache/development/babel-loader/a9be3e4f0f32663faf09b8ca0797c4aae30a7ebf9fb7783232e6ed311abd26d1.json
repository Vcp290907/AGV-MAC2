{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\vcp_2\\\\Desktop\\\\Bentao\\\\TCC\\\\AGV-MAC2\\\\agv-mobile\\\\node_modules\\\\expo-camera\\\\build\\\\CameraView.js\";\nimport { Platform, UnavailabilityError } from 'expo-modules-core';\nimport { Component, createRef } from 'react';\nimport ExpoCamera from './ExpoCamera';\nimport CameraManager from './ExpoCameraManager';\nimport { ConversionTables, ensureNativeProps } from './utils/props';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst EventThrottleMs = 500;\nconst _PICTURE_SAVED_CALLBACKS = {};\nlet loggedRenderingChildrenWarning = false;\nlet _GLOBAL_PICTURE_ID = 1;\nfunction ensurePictureOptions(options) {\n  if (!options || typeof options !== 'object') {\n    return {};\n  }\n  if (options.quality === undefined) {\n    options.quality = 1;\n  }\n  if (options.mirror) {\n    console.warn('The `mirror` option is deprecated. Please use the `mirror` prop on the `CameraView` instead.');\n  }\n  if (options.onPictureSaved) {\n    const id = _GLOBAL_PICTURE_ID++;\n    _PICTURE_SAVED_CALLBACKS[id] = options.onPictureSaved;\n    options.id = id;\n    options.fastMode = true;\n  }\n  return options;\n}\nfunction ensureRecordingOptions(options = {}) {\n  if (!options || typeof options !== 'object') {\n    return {};\n  }\n  if (options.mirror) {\n    console.warn('The `mirror` option is deprecated. Please use the `mirror` prop on the `CameraView` instead.');\n  }\n  return options;\n}\nfunction _onPictureSaved({\n  nativeEvent\n}) {\n  const {\n    id,\n    data\n  } = nativeEvent;\n  const callback = _PICTURE_SAVED_CALLBACKS[id];\n  if (callback) {\n    callback(data);\n    delete _PICTURE_SAVED_CALLBACKS[id];\n  }\n}\nexport default class CameraView extends Component {\n  static isModernBarcodeScannerAvailable = CameraManager.isModernBarcodeScannerAvailable;\n  static async isAvailableAsync() {\n    if (!CameraManager.isAvailableAsync) {\n      throw new UnavailabilityError('expo-camera', 'isAvailableAsync');\n    }\n    return CameraManager.isAvailableAsync();\n  }\n  static async getAvailableVideoCodecsAsync() {\n    if (!CameraManager.getAvailableVideoCodecsAsync) {\n      throw new UnavailabilityError('Camera', 'getAvailableVideoCodecsAsync');\n    }\n    return CameraManager.getAvailableVideoCodecsAsync();\n  }\n  async getAvailablePictureSizesAsync() {\n    return (await this._cameraRef.current?.getAvailablePictureSizes()) ?? [];\n  }\n  async getAvailableLensesAsync() {\n    return (await this._cameraRef.current?.getAvailableLenses()) ?? [];\n  }\n  getSupportedFeatures() {\n    return {\n      isModernBarcodeScannerAvailable: CameraManager.isModernBarcodeScannerAvailable,\n      toggleRecordingAsyncAvailable: CameraManager.toggleRecordingAsyncAvailable\n    };\n  }\n  async resumePreview() {\n    return this._cameraRef.current?.resumePreview();\n  }\n  async pausePreview() {\n    return this._cameraRef.current?.pausePreview();\n  }\n  static ConversionTables = ConversionTables;\n  static defaultProps = {\n    zoom: 0,\n    facing: 'back',\n    enableTorch: false,\n    mode: 'picture',\n    flash: 'off'\n  };\n  _cameraRef = createRef();\n  _lastEvents = {};\n  _lastEventsTimes = {};\n  async takePictureAsync(options) {\n    const pictureOptions = ensurePictureOptions(options);\n    if (Platform.OS === 'ios' && options?.pictureRef) {\n      return this._cameraRef.current?.takePictureRef?.(options);\n    }\n    return this._cameraRef.current?.takePicture(pictureOptions);\n  }\n  static async launchScanner(options) {\n    if (!options) {\n      options = {\n        barcodeTypes: []\n      };\n    }\n    if (Platform.OS !== 'web' && CameraView.isModernBarcodeScannerAvailable) {\n      await CameraManager.launchScanner(options);\n    }\n  }\n  static async dismissScanner() {\n    if (Platform.OS !== 'web' && CameraView.isModernBarcodeScannerAvailable) {\n      await CameraManager.dismissScanner();\n    }\n  }\n  static onModernBarcodeScanned(listener) {\n    return CameraManager.addListener('onModernBarcodeScanned', listener);\n  }\n  async recordAsync(options) {\n    const recordingOptions = ensureRecordingOptions(options);\n    return this._cameraRef.current?.record(recordingOptions);\n  }\n  async toggleRecordingAsync() {\n    return this._cameraRef.current?.toggleRecording();\n  }\n  stopRecording() {\n    this._cameraRef.current?.stopRecording();\n  }\n  _onCameraReady = () => {\n    if (this.props.onCameraReady) {\n      this.props.onCameraReady();\n    }\n  };\n  _onAvailableLensesChanged = ({\n    nativeEvent\n  }) => {\n    if (this.props.onAvailableLensesChanged) {\n      this.props.onAvailableLensesChanged(nativeEvent);\n    }\n  };\n  _onMountError = ({\n    nativeEvent\n  }) => {\n    if (this.props.onMountError) {\n      this.props.onMountError(nativeEvent);\n    }\n  };\n  _onResponsiveOrientationChanged = ({\n    nativeEvent\n  }) => {\n    if (this.props.onResponsiveOrientationChanged) {\n      this.props.onResponsiveOrientationChanged(nativeEvent);\n    }\n  };\n  _onObjectDetected = callback => ({\n    nativeEvent\n  }) => {\n    const {\n      type\n    } = nativeEvent;\n    if (this._lastEvents[type] && this._lastEventsTimes[type] && JSON.stringify(nativeEvent) === this._lastEvents[type] && new Date().getTime() - this._lastEventsTimes[type].getTime() < EventThrottleMs) {\n      return;\n    }\n    if (callback) {\n      callback(nativeEvent);\n      this._lastEventsTimes[type] = new Date();\n      this._lastEvents[type] = JSON.stringify(nativeEvent);\n    }\n  };\n  _setReference = ref => {\n    if (ref) {\n      if (Platform.OS === 'web') {\n        this._cameraHandle = ref;\n      }\n    }\n  };\n  render() {\n    const nativeProps = ensureNativeProps(this.props);\n    const onBarcodeScanned = this.props.onBarcodeScanned ? this._onObjectDetected(this.props.onBarcodeScanned) : undefined;\n    if (nativeProps.children && !loggedRenderingChildrenWarning) {\n      console.warn('The <CameraView> component does not support children. This may lead to inconsistent behaviour or crashes. If you want to render content on top of the Camera, consider using absolute positioning.');\n      loggedRenderingChildrenWarning = true;\n    }\n    return _jsxDEV(ExpoCamera, Object.assign({}, nativeProps, {\n      ref: this._cameraRef,\n      onCameraReady: this._onCameraReady,\n      onMountError: this._onMountError,\n      onBarcodeScanned: onBarcodeScanned,\n      onAvailableLensesChanged: this._onAvailableLensesChanged,\n      onPictureSaved: _onPictureSaved,\n      onResponsiveOrientationChanged: this._onResponsiveOrientationChanged\n    }), void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 258,\n      columnNumber: 17\n    }, this);\n  }\n}","map":{"version":3,"names":["Platform","UnavailabilityError","Component","createRef","ExpoCamera","CameraManager","ConversionTables","ensureNativeProps","jsxDEV","_jsxDEV","EventThrottleMs","_PICTURE_SAVED_CALLBACKS","loggedRenderingChildrenWarning","_GLOBAL_PICTURE_ID","ensurePictureOptions","options","quality","undefined","mirror","console","warn","onPictureSaved","id","fastMode","ensureRecordingOptions","_onPictureSaved","nativeEvent","data","callback","CameraView","isModernBarcodeScannerAvailable","isAvailableAsync","getAvailableVideoCodecsAsync","getAvailablePictureSizesAsync","_cameraRef","current","getAvailablePictureSizes","getAvailableLensesAsync","getAvailableLenses","getSupportedFeatures","toggleRecordingAsyncAvailable","resumePreview","pausePreview","defaultProps","zoom","facing","enableTorch","mode","flash","_lastEvents","_lastEventsTimes","takePictureAsync","pictureOptions","OS","pictureRef","takePictureRef","takePicture","launchScanner","barcodeTypes","dismissScanner","onModernBarcodeScanned","listener","addListener","recordAsync","recordingOptions","record","toggleRecordingAsync","toggleRecording","stopRecording","_onCameraReady","props","onCameraReady","_onAvailableLensesChanged","onAvailableLensesChanged","_onMountError","onMountError","_onResponsiveOrientationChanged","onResponsiveOrientationChanged","_onObjectDetected","type","JSON","stringify","Date","getTime","_setReference","ref","_cameraHandle","render","nativeProps","onBarcodeScanned","children","Object","assign","fileName","_jsxFileName","lineNumber","columnNumber"],"sources":["C:\\Users\\vcp_2\\Desktop\\Bentao\\TCC\\AGV-MAC2\\agv-mobile\\node_modules\\expo-camera\\src\\CameraView.tsx"],"sourcesContent":["import { Platform, UnavailabilityError, type EventSubscription } from 'expo-modules-core';\nimport { type Ref, Component, createRef } from 'react';\n\nimport {\n  CameraCapturedPicture,\n  CameraOrientation,\n  CameraPictureOptions,\n  CameraViewProps,\n  CameraRecordingOptions,\n  CameraViewRef,\n  ScanningOptions,\n  ScanningResult,\n  VideoCodec,\n  AvailableLenses,\n} from './Camera.types';\nimport ExpoCamera from './ExpoCamera';\nimport CameraManager from './ExpoCameraManager';\nimport { PictureRef } from './PictureRef';\nimport { ConversionTables, ensureNativeProps } from './utils/props';\n\nconst EventThrottleMs = 500;\n\nconst _PICTURE_SAVED_CALLBACKS: Record<number, CameraPictureOptions['onPictureSaved'] | undefined> =\n  {};\n\nlet loggedRenderingChildrenWarning = false;\nlet _GLOBAL_PICTURE_ID = 1;\n\nfunction ensurePictureOptions(options?: CameraPictureOptions): CameraPictureOptions {\n  if (!options || typeof options !== 'object') {\n    return {};\n  }\n\n  if (options.quality === undefined) {\n    options.quality = 1;\n  }\n\n  if (options.mirror) {\n    console.warn(\n      'The `mirror` option is deprecated. Please use the `mirror` prop on the `CameraView` instead.'\n    );\n  }\n\n  if (options.onPictureSaved) {\n    const id = _GLOBAL_PICTURE_ID++;\n    _PICTURE_SAVED_CALLBACKS[id] = options.onPictureSaved;\n    options.id = id;\n    options.fastMode = true;\n  }\n\n  return options;\n}\n\nfunction ensureRecordingOptions(options: CameraRecordingOptions = {}): CameraRecordingOptions {\n  if (!options || typeof options !== 'object') {\n    return {};\n  }\n\n  if (options.mirror) {\n    console.warn(\n      'The `mirror` option is deprecated. Please use the `mirror` prop on the `CameraView` instead.'\n    );\n  }\n\n  return options;\n}\n\nfunction _onPictureSaved({\n  nativeEvent,\n}: {\n  nativeEvent: { data: CameraCapturedPicture; id: number };\n}) {\n  const { id, data } = nativeEvent;\n  const callback = _PICTURE_SAVED_CALLBACKS[id];\n  if (callback) {\n    callback(data);\n    delete _PICTURE_SAVED_CALLBACKS[id];\n  }\n}\n\nexport default class CameraView extends Component<CameraViewProps> {\n  /**\n   * Property that determines if the current device has the ability to use `DataScannerViewController` (iOS 16+).\n   */\n  static isModernBarcodeScannerAvailable: boolean = CameraManager.isModernBarcodeScannerAvailable;\n  /**\n   * Check whether the current device has a camera. This is useful for web and simulators cases.\n   * This isn't influenced by the Permissions API (all platforms), or HTTP usage (in the browser).\n   * You will still need to check if the native permission has been accepted.\n   * @platform web\n   */\n  static async isAvailableAsync(): Promise<boolean> {\n    if (!CameraManager.isAvailableAsync) {\n      throw new UnavailabilityError('expo-camera', 'isAvailableAsync');\n    }\n\n    return CameraManager.isAvailableAsync();\n  }\n\n  // @needsAudit\n  /**\n   * Queries the device for the available video codecs that can be used in video recording.\n   * @return A promise that resolves to a list of strings that represents available codecs.\n   * @platform ios\n   */\n  static async getAvailableVideoCodecsAsync(): Promise<VideoCodec[]> {\n    if (!CameraManager.getAvailableVideoCodecsAsync) {\n      throw new UnavailabilityError('Camera', 'getAvailableVideoCodecsAsync');\n    }\n\n    return CameraManager.getAvailableVideoCodecsAsync();\n  }\n\n  /**\n   * Get picture sizes that are supported by the device.\n   * @return Returns a Promise that resolves to an array of strings representing picture sizes that can be passed to `pictureSize` prop.\n   * The list varies across Android devices but is the same for every iOS.\n   */\n  async getAvailablePictureSizesAsync(): Promise<string[]> {\n    return (await this._cameraRef.current?.getAvailablePictureSizes()) ?? [];\n  }\n\n  /**\n   * Returns the available lenses for the currently selected camera.\n   *\n   * @return Returns a Promise that resolves to an array of strings representing the lens type that can be passed to `selectedLens` prop.\n   * @platform ios\n   */\n  async getAvailableLensesAsync(): Promise<string[]> {\n    return (await this._cameraRef.current?.getAvailableLenses()) ?? [];\n  }\n\n  /**\n   * Returns an object with the supported features of the camera on the current device.\n   */\n  getSupportedFeatures(): {\n    isModernBarcodeScannerAvailable: boolean;\n    toggleRecordingAsyncAvailable: boolean;\n  } {\n    return {\n      isModernBarcodeScannerAvailable: CameraManager.isModernBarcodeScannerAvailable,\n      toggleRecordingAsyncAvailable: CameraManager.toggleRecordingAsyncAvailable,\n    };\n  }\n\n  /**\n   * Resumes the camera preview.\n   */\n  async resumePreview(): Promise<void> {\n    return this._cameraRef.current?.resumePreview();\n  }\n\n  /**\n   * Pauses the camera preview. It is not recommended to use `takePictureAsync` when preview is paused.\n   */\n  async pausePreview(): Promise<void> {\n    return this._cameraRef.current?.pausePreview();\n  }\n\n  // Values under keys from this object will be transformed to native options\n  static ConversionTables = ConversionTables;\n\n  static defaultProps: CameraViewProps = {\n    zoom: 0,\n    facing: 'back',\n    enableTorch: false,\n    mode: 'picture',\n    flash: 'off',\n  };\n\n  _cameraHandle?: number | null;\n  _cameraRef = createRef<CameraViewRef>();\n  _lastEvents: { [eventName: string]: string } = {};\n  _lastEventsTimes: { [eventName: string]: Date } = {};\n\n  // @needsAudit\n  /**\n   * Takes a picture and saves it to app's cache directory. Photos are rotated to match device's orientation\n   * (if `options.skipProcessing` flag is not enabled) and scaled to match the preview.\n   * > **Note**: Make sure to wait for the [`onCameraReady`](#oncameraready) callback before calling this method.\n   * @param options An object in form of `CameraPictureOptions` type.\n   * @return Returns a Promise that resolves to `CameraCapturedPicture` object, where `uri` is a URI to the local image file on Android,\n   * iOS, and a base64 string on web (usable as the source for an `Image` element). The `width` and `height` properties specify\n   * the dimensions of the image.\n   *\n   * `base64` is included if the `base64` option was truthy, and is a string containing the JPEG data\n   * of the image in Base64. Prepend it with `'data:image/jpg;base64,'` to get a data URI, which you can use as the source\n   * for an `Image` element for example.\n   *\n   * `exif` is included if the `exif` option was truthy, and is an object containing EXIF\n   * data for the image. The names of its properties are EXIF tags and their values are the values for those tags.\n   *\n   * > On native platforms, the local image URI is temporary. Use [`FileSystem.copyAsync`](filesystem/#filesystemcopyasyncoptions)\n   * > to make a permanent copy of the image.\n   *\n   * > **Note:** Avoid calling this method while the preview is paused. On Android, this will throw an error. On iOS, this will take a picture of the last frame that is currently on screen.\n   */\n  async takePictureAsync(options: CameraPictureOptions & { pictureRef: true }): Promise<PictureRef>;\n  async takePictureAsync(options?: CameraPictureOptions): Promise<CameraCapturedPicture>;\n  async takePictureAsync(options?: CameraPictureOptions) {\n    const pictureOptions = ensurePictureOptions(options);\n\n    if (Platform.OS === 'ios' && options?.pictureRef) {\n      return this._cameraRef.current?.takePictureRef?.(options);\n    }\n    return this._cameraRef.current?.takePicture(pictureOptions);\n  }\n\n  /**\n   * On Android, we will use the [Google code scanner](https://developers.google.com/ml-kit/vision/barcode-scanning/code-scanner).\n   * On iOS, presents a modal view controller that uses the [`DataScannerViewController`](https://developer.apple.com/documentation/visionkit/scanning_data_with_the_camera) available on iOS 16+.\n   * @platform android\n   * @platform ios\n   */\n  static async launchScanner(options?: ScanningOptions): Promise<void> {\n    if (!options) {\n      options = { barcodeTypes: [] };\n    }\n    if (Platform.OS !== 'web' && CameraView.isModernBarcodeScannerAvailable) {\n      await CameraManager.launchScanner(options);\n    }\n  }\n\n  /**\n   * Dismiss the scanner presented by `launchScanner`.\n   * > **info** On Android, the scanner is dismissed automatically when a barcode is scanned.\n   * @platform ios\n   */\n  static async dismissScanner(): Promise<void> {\n    if (Platform.OS !== 'web' && CameraView.isModernBarcodeScannerAvailable) {\n      await CameraManager.dismissScanner();\n    }\n  }\n\n  /**\n   * Invokes the `listener` function when a bar code has been successfully scanned. The callback is provided with\n   * an object of the `ScanningResult` shape, where the `type` refers to the bar code type that was scanned and the `data` is the information encoded in the bar code\n   * (in this case of QR codes, this is often a URL). See [`BarcodeType`](#barcodetype) for supported values.\n   * @param listener Invoked with the [ScanningResult](#scanningresult) when a bar code has been successfully scanned.\n   *\n   * @platform ios\n   * @platform android\n   */\n  static onModernBarcodeScanned(listener: (event: ScanningResult) => void): EventSubscription {\n    return CameraManager.addListener('onModernBarcodeScanned', listener);\n  }\n\n  /**\n   * Starts recording a video that will be saved to cache directory. Videos are rotated to match device's orientation.\n   * Flipping camera during a recording results in stopping it.\n   * @param options A map of `CameraRecordingOptions` type.\n   * @return Returns a Promise that resolves to an object containing video file `uri` property and a `codec` property on iOS.\n   * The Promise is returned if `stopRecording` was invoked, one of `maxDuration` and `maxFileSize` is reached or camera preview is stopped.\n   * @platform android\n   * @platform ios\n   */\n  async recordAsync(options?: CameraRecordingOptions) {\n    const recordingOptions = ensureRecordingOptions(options);\n    return this._cameraRef.current?.record(recordingOptions);\n  }\n\n  /**\n   * Pauses or resumes the video recording. Only has an effect if there is an active recording. On `iOS`, this method only supported on `iOS` 18.\n   *\n   * @example\n   * ```ts\n   * const { toggleRecordingAsyncAvailable } = getSupportedFeatures()\n   *\n   * return (\n   *  {toggleRecordingAsyncAvailable && (\n   *    <Button title=\"Toggle Recording\" onPress={toggleRecordingAsync} />\n   *  )}\n   * )\n   * ```\n   */\n  async toggleRecordingAsync() {\n    return this._cameraRef.current?.toggleRecording();\n  }\n\n  /**\n   * Stops recording if any is in progress.\n   * @platform android\n   * @platform ios\n   */\n  stopRecording() {\n    this._cameraRef.current?.stopRecording();\n  }\n\n  _onCameraReady = () => {\n    if (this.props.onCameraReady) {\n      this.props.onCameraReady();\n    }\n  };\n\n  _onAvailableLensesChanged = ({ nativeEvent }: { nativeEvent: AvailableLenses }) => {\n    if (this.props.onAvailableLensesChanged) {\n      this.props.onAvailableLensesChanged(nativeEvent);\n    }\n  };\n\n  _onMountError = ({ nativeEvent }: { nativeEvent: { message: string } }) => {\n    if (this.props.onMountError) {\n      this.props.onMountError(nativeEvent);\n    }\n  };\n\n  _onResponsiveOrientationChanged = ({\n    nativeEvent,\n  }: {\n    nativeEvent: { orientation: CameraOrientation };\n  }) => {\n    if (this.props.onResponsiveOrientationChanged) {\n      this.props.onResponsiveOrientationChanged(nativeEvent);\n    }\n  };\n\n  _onObjectDetected =\n    (callback?: Function) =>\n    ({ nativeEvent }: { nativeEvent: any }) => {\n      const { type } = nativeEvent;\n      if (\n        this._lastEvents[type] &&\n        this._lastEventsTimes[type] &&\n        JSON.stringify(nativeEvent) === this._lastEvents[type] &&\n        new Date().getTime() - this._lastEventsTimes[type].getTime() < EventThrottleMs\n      ) {\n        return;\n      }\n\n      if (callback) {\n        callback(nativeEvent);\n        this._lastEventsTimes[type] = new Date();\n        this._lastEvents[type] = JSON.stringify(nativeEvent);\n      }\n    };\n\n  _setReference = (ref: Ref<CameraViewRef>) => {\n    if (ref) {\n      // TODO(Bacon): Unify these - perhaps with hooks?\n      if (Platform.OS === 'web') {\n        this._cameraHandle = ref as any;\n      }\n    }\n  };\n\n  render() {\n    const nativeProps = ensureNativeProps(this.props);\n    const onBarcodeScanned = this.props.onBarcodeScanned\n      ? this._onObjectDetected(this.props.onBarcodeScanned)\n      : undefined;\n\n    // @ts-expect-error\n    if (nativeProps.children && !loggedRenderingChildrenWarning) {\n      console.warn(\n        'The <CameraView> component does not support children. This may lead to inconsistent behaviour or crashes. If you want to render content on top of the Camera, consider using absolute positioning.'\n      );\n      loggedRenderingChildrenWarning = true;\n    }\n\n    return (\n      <ExpoCamera\n        {...nativeProps}\n        ref={this._cameraRef}\n        onCameraReady={this._onCameraReady}\n        onMountError={this._onMountError}\n        onBarcodeScanned={onBarcodeScanned}\n        onAvailableLensesChanged={this._onAvailableLensesChanged}\n        onPictureSaved={_onPictureSaved}\n        onResponsiveOrientationChanged={this._onResponsiveOrientationChanged}\n      />\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}